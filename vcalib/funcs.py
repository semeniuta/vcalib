import cv2
import os
import sys
import numpy as np
import pandas as pd
from glob import glob
import itertools

from visioncg.io import sorted_glob
from visioncg import cbcalib
from visioncg import geometry
from epypes.compgraph import CompGraphRunner

from .io import open_images_all


def prepare_points_for_all_images(runner_prepare, imfiles_1, imfiles_2):
    
    all_images_1 = open_images_all(imfiles_1)
    all_images_2 = open_images_all(imfiles_2)
    
    runner_prepare.run(
        calibration_images_1=all_images_1,
        calibration_images_2=all_images_2
    )
    
    
def run_calib(runner_calib, impoints_1, impoints_2, indices_subset, pattern_points):
    
    imp_1 = [impoints_1[idx] for idx in indices_subset]
    imp_2 = [impoints_2[idx] for idx in indices_subset]
    obp = cbcalib.make_list_of_identical_pattern_points(len(indices_subset), pattern_points)

    runner_calib.run(
        image_points_1=imp_1,
        image_points_2=imp_2,
        object_points=obp
    )
        
    
def all_images_reprojection_error_for_subsets(indices_subset_gen, runner_prepare, runner_calib):
    """
    For each indices subset generated by indices_subset_gen,
    perform stereo calibration. Then, given the resulting intrinsics,
    solve PnP problem and compute reprojection error for all images.
    Return two NumPy arrays of equal length, where each element 
    corresponds to reprojection error given all images 
    and intrinsics from calibration based on a specific images subset.
    """
    
    rms_list_1 = []
    rms_list_2 = []
    
    # for all images
    impoints_1 = runner_prepare['image_points_1']
    impoints_2 = runner_prepare['image_points_2']
    pattern_points = runner_prepare['pattern_points']
    
    def multiple_pnp(impoints, cm, dc): # capturing object_points

        rvecs = []
        tvecs = []

        for imp in impoints:
            _, rvec, tvec = cv2.solvePnP(pattern_points, imp, cm, dc) 
            rvecs.append(rvec)
            tvecs.append(tvec)

        return rvecs, tvecs
    
    object_points = cbcalib.make_list_of_identical_pattern_points(len(impoints_1), pattern_points)

    for indices_subset in indices_subset_gen:
       
        run_calib(runner_calib, impoints_1, impoints_2, indices_subset, pattern_points)
        
        cm1 = runner_calib['cm_1']
        dc1 = runner_calib['dc_1']
        cm2 = runner_calib['cm_2']
        dc2 = runner_calib['dc_2']
        
        rvecs1, tvecs1 = multiple_pnp(impoints_1, cm1, dc1)
        rvecs2, tvecs2 = multiple_pnp(impoints_2, cm2, dc2)
        
        rms1 = cbcalib.reproject_and_measure_error(impoints_1, object_points, rvecs1, tvecs1, cm1, dc1)
        rms2 = cbcalib.reproject_and_measure_error(impoints_2, object_points, rvecs2, tvecs2, cm2, dc2)

        rms_list_1.append(rms1)
        rms_list_2.append(rms2)
        
    return np.array(rms_list_1), np.array(rms_list_2)


def cb_row_by_row(pattern_size):
    """
    Generator of pairs of (start, end)
    indices of a chessboard pattern 
    per each row. 
    """
    
    n_cols, n_rows = pattern_size
    
    idx = 0
    
    for i in range(n_rows):
        start = i * n_cols
        end = start + n_cols
        yield start, end
        
        
def measure_cb_distances_in_rows(points_3d, pattern_size):
    
    distances = []

    n_cols, n_rows = pattern_size
    assert len(points_3d) == (n_cols * n_rows)
    
    for start, end in cb_row_by_row(pattern_size):
        
        row_points = points_3d[start:end]
        
        for i in range(len(row_points) - 1):
            p1 = row_points[i]
            p2 = row_points[i + 1]
            dist = np.linalg.norm(p1 - p2)
            distances.append(dist)
            
    return np.array(distances)
        

def all_images_triangulate_for_subsets(indices_subset_gen, runner_prepare, runner_calib):
        
    impoints_1 = runner_prepare['image_points_1']
    impoints_2 = runner_prepare['image_points_2']
    pattern_points = runner_prepare['pattern_points']
    pattern_size = runner_prepare['pattern_size_wh']
    
    res = []
    
    for indices_subset in indices_subset_gen:
        
        run_calib(runner_calib, impoints_1, impoints_2, indices_subset, pattern_points)
            
        points_3d_all_images = geometry.triangulate_impoints(
            runner_calib['P1'], 
            runner_calib['P2'], 
            runner_prepare['image_points_1'], 
            runner_prepare['image_points_2']
        )
        
        points_3d_calib_images = geometry.triangulate_impoints(
            runner_calib['P1'], 
            runner_calib['P2'], 
            runner_calib['image_points_1'], 
            runner_calib['image_points_2']
        )
       
        measure = lambda p3d: measure_cb_distances_in_rows(p3d, pattern_size)                           
        
        distances_all = [measure(p3d).mean() for p3d in points_3d_all_images]
        distances_calib = [measure(p3d).mean() for p3d in points_3d_calib_images]
        
        res.append(distances_all)
 
    # rows -- calibration runs
    # cols -- images
    return np.array(res) 


def detect_good_triangulations(res_np, target, tol):
    
    bottom = target - tol
    top = target + tol
    
    return(res_np > bottom) & (res_np < top)


def find_best_calib_based_on_triangulations(good):
    
    ngood_per_calib = np.sum(good, axis=1) 
    best_calib_run_idx = ngood_per_calib.argmax()
    good_image_indices_in_best_calib = np.nonzero(good[best_calib_run_idx])[0]
    
    return ngood_per_calib, best_calib_run_idx, good_image_indices_in_best_calib


def analyze_good_tringulations(good):
    
    calib_runs_with_nonzero_good = dict()

    for calib_idx in range(len(good)):
        calib_metrics = good[calib_idx, :]
        n_good = np.sum(calib_metrics)
        if n_good > 0:
            calib_runs_with_nonzero_good[calib_idx] = calib_metrics

    good_images = dict()

    for k, v in calib_runs_with_nonzero_good.items():
        
        nonzero_indices = np.nonzero(v)[0]

        for idx in nonzero_indices:
            if idx not in good_images:
                good_images[idx] = 1
            else:
                good_images[idx] += 1
                
    good_counts = dict()
    
    for im_idx, c in good_images.items():
        
        if c not in good_counts:
            good_counts[c] = [im_idx]
        else:
            good_counts[c].append(im_idx)
                
    return calib_runs_with_nonzero_good, good_counts


def select_indices(good_counts, low_threshold=0):
    
    selected = [] 
    
    counts =  filter(lambda c: c > low_threshold, good_counts.keys())
    
    for c in counts:
        selected += good_counts[c]
        
    return selected