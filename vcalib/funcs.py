import cv2
import os
import sys
import numpy as np
import pandas as pd
from glob import glob
from math import factorial
import itertools
import random
from matplotlib import pyplot as plt

from visioncg.io import sorted_glob
from visioncg.io import open_image
from visioncg import cbcalib
from visioncg import geometry
from epypes.compgraph import CompGraphRunner


def glob_images(data_dir, camera_idx):
    mask = os.path.join(data_dir, 'img_{}_*.jpg'.format(camera_idx))
    return sorted_glob(mask)


def n_choose_k(n, k):
    return factorial(n) / (factorial(k) * factorial(n - k))


def shuffle(x, seed=None):
    
    if seed is None:
        rnd = random.Random() 
    else:
        rnd = random.Random(seed) 
        
    rnd.shuffle(x)
    
    
def shuffle_indices(n, seed=42):
    
    indices = list(range(n))
    shuffle(indices, seed)
    
    return indices


def imshow_noaxis(ax, im):
    ax.imshow(im)
    ax.axis('off')
    
    
def subsets_sliding(indices, subset_size):
    
    total = len(indices)
    
    if subset_size > total:
        raise Exception('subset_size should be less or equal to the size of indices')
        
    last = total - subset_size
        
    for start in range(0, last + 1):
        yield indices[start:start+subset_size]

        
def open_images_all(imfiles):
    
    def open_image_gray(im_filename):
        return open_image(im_filename, read_flag=cv2.IMREAD_GRAYSCALE)
    
    return [open_image_gray(imf) for imf in imfiles] 
    
      
def open_images_subset(imfiles, subset_indices):
    
    def open_image_gray_by_idx(idx):
        return open_image(imfiles[idx], read_flag=cv2.IMREAD_GRAYSCALE)
    
    return [open_image_gray_by_idx(idx) for idx in subset_indices]


def open_images_subset_stereo(imfiles_1, imfiles_2, subset_indices):
    
    images_1 = open_images_subset(imfiles_1, subset_indices)
    images_2 = open_images_subset(imfiles_2, subset_indices)
    
    return images_1, images_2

    
def calibrate_stereo(images_1, images_2):
    
    cg = cbcalib.CGCalibrateStereo()

    params = {
        'im_wh': cbcalib.get_im_wh(images_1[0]),
        'pattern_size_wh': (9, 7),
        'square_size': 20.   
    }

    runner = CompGraphRunner(cg, params)
    
    runner.run(calibration_images_1=images_1, calibration_images_2=images_2)
    
    return runner


def reproject_and_measure_error(image_points, object_points, rvecs, tvecs, cm, dc):
    
    reproj_list = []
    
    for ip, op, rvec, tvec in zip(image_points, object_points, rvecs, tvecs):

        ip_reprojected = cbcalib.project_points(op, rvec, tvec, cm, dc)
        reproj_list.append(ip_reprojected)
        
    reproj_all = np.concatenate(reproj_list, axis=0)
    original_all = np.concatenate(image_points, axis=0)
    
    rms = cbcalib.reprojection_rms(original_all, reproj_all)
    return rms


def prepare_points_for_all_images(runner_prepare, imfiles_1, imfiles_2):
    
    all_images_1 = open_images_all(imfiles_1)
    all_images_2 = open_images_all(imfiles_2)
    
    runner_prepare.run(
        calibration_images_1=all_images_1,
        calibration_images_2=all_images_2
    )
    
    
def run_calib(runner_calib, impoints_1, impoints_2, indices_subset, pattern_points):
    
    imp_1 = [impoints_1[idx] for idx in indices_subset]
    imp_2 = [impoints_2[idx] for idx in indices_subset]
    obp = cbcalib.make_list_of_identical_pattern_points(len(indices_subset), pattern_points)

    runner_calib.run(
        image_points_1=imp_1,
        image_points_2=imp_2,
        object_points=obp
    )
        
    
def all_images_reprojection_error_for_subsets(indices_subset_gen, runner_prepare, runner_calib):
    """
    For each indices subset generated by indices_subset_gen,
    perform stereo calibration. Then, given the resulting intrinsics,
    solve PnP problem and compute reprojection error for all images.
    Return two NumPy arrays of equal length, where each element 
    corresponds to reprojection error given all images 
    and intrinsics from calibration based on a specific images subset.
    """
    
    rms_list_1 = []
    rms_list_2 = []
    
    # for all images
    impoints_1 = runner_prepare['image_points_1']
    impoints_2 = runner_prepare['image_points_2']
    pattern_points = runner_prepare['pattern_points']
    
    def multiple_pnp(impoints, cm, dc): # capturing object_points

        rvecs = []
        tvecs = []

        for imp in impoints:
            _, rvec, tvec = cv2.solvePnP(pattern_points, imp, cm, dc) 
            rvecs.append(rvec)
            tvecs.append(tvec)

        return rvecs, tvecs
    
    object_points = cbcalib.make_list_of_identical_pattern_points(len(impoints_1), pattern_points)

    for indices_subset in indices_subset_gen:
       
        run_calib(runner_calib, impoints_1, impoints_2, indices_subset, pattern_points)
        
        cm1 = runner_calib['cm_1']
        dc1 = runner_calib['dc_1']
        cm2 = runner_calib['cm_2']
        dc2 = runner_calib['dc_2']
        
        rvecs1, tvecs1 = multiple_pnp(impoints_1, cm1, dc1)
        rvecs2, tvecs2 = multiple_pnp(impoints_2, cm2, dc2)
        
        rms1 = reproject_and_measure_error(impoints_1, object_points, rvecs1, tvecs1, cm1, dc1)
        rms2 = reproject_and_measure_error(impoints_2, object_points, rvecs2, tvecs2, cm2, dc2)

        rms_list_1.append(rms1)
        rms_list_2.append(rms2)
        
        """
        p3d = geometry.triangulate_points(
            runner_calib['P1'],
            runner_calib['P2'],
            runner_prepare['image_points_1'][0],
            runner_prepare['image_points_2'][0]
        )
        print(np.linalg.norm(p3d[0] - p3d[1]))
        """
        
    return np.array(rms_list_1), np.array(rms_list_2)


def create_runner_stereocalib(params):
    cg = cbcalib.CGCalibrateStereoBase()
    return CompGraphRunner(cg, params)     
       

def triangulate_impoints(P1, P2, impoints_1, impoints_2):
    
    points_3d_list = []
    
    for imp_1, imp_2 in zip(impoints_1, impoints_2):

        points_3d = geometry.triangulate_points(P1, P2, imp_1, imp_2)
        points_3d_list.append(points_3d)
        
    return points_3d_list


"""
class StereoCalibEval:
    
    def __init__(self, params_calib):
        self._runner_calib = create_runner_stereocalib(params_calib)
        self.prepare()
        
    def ():
        
    

def calibrate_per_subset_and_eval(indices_subset_gen, runner_prepare, proc_func):
    
    for indices_subset in indices_subset_gen:
"""  

def cb_row_by_row(pattern_size, arr):
    
    n_cols, n_rows = pattern_size
    
    assert len(arr) == (n_cols * n_rows)
    
    idx = 0
    
    for i in range(n_rows):
        start = i * n_cols
        end = start + n_cols
        yield start, end
        
        
def measure_cb_distances_in_rows(points_3d, pattern_size):
    
    distances = []
    
    for start, end in cb_row_by_row(pattern_size, points_3d):
        
        row_points = points_3d[start:end]
        
        for i in range(len(row_points) - 1):
            p1 = row_points[i]
            p2 = row_points[i + 1]
            dist = np.linalg.norm(p1 - p2)
            distances.append(dist)
            
    return np.array(distances)
        

def all_images_triangulate_for_subsets(indices_subset_gen, runner_prepare, runner_calib):
        
    impoints_1 = runner_prepare['image_points_1']
    impoints_2 = runner_prepare['image_points_2']
    pattern_points = runner_prepare['pattern_points']
    pattern_size = runner_prepare['pattern_size_wh']
    
    res = []
    
    for indices_subset in indices_subset_gen:
        
        run_calib(runner_calib, impoints_1, impoints_2, indices_subset, pattern_points)
            
        points_3d_all_images = triangulate_impoints(
            runner_calib['P1'], 
            runner_calib['P2'], 
            runner_prepare['image_points_1'], 
            runner_prepare['image_points_2']
        )
        
        points_3d_calib_images = triangulate_impoints(
            runner_calib['P1'], 
            runner_calib['P2'], 
            runner_calib['image_points_1'], 
            runner_calib['image_points_2']
        )
       
        measure = lambda p3d: measure_cb_distances_in_rows(p3d, pattern_size)                           
        
        distances_all = [measure(p3d).mean() for p3d in points_3d_all_images]
        distances_calib = [measure(p3d).mean() for p3d in points_3d_calib_images]
        
        res.append(distances_all)
 
    # rows -- calibration runs
    # cols -- images
    return np.array(res) 


def detect_good_triangulations(res_np, target, tol):
    
    bottom = target - tol
    top = target + tol
    
    return(res_np > bottom) & (res_np < top)


def find_best_calib_based_on_triangulations(good):
    
    ngood_per_calib = np.sum(good, axis=1) 
    best_calib_run_idx = ngood_per_calib.argmax()
    good_image_indices_in_best_calib = np.nonzero(good[best_calib_run_idx])[0]
    
    return ngood_per_calib, best_calib_run_idx, good_image_indices_in_best_calib


def analyze_good_tringulations(good):
    
    calib_runs_with_nonzero_good = dict()

    for calib_idx in range(len(good)):
        calib_metrics = good[calib_idx, :]
        n_good = np.sum(calib_metrics)
        if n_good > 0:
            calib_runs_with_nonzero_good[calib_idx] = calib_metrics

    good_images = dict()

    for k, v in calib_runs_with_nonzero_good.items():
        
        nonzero_indices = np.nonzero(v)[0]

        for idx in nonzero_indices:
            if idx not in good_images:
                good_images[idx] = 1
            else:
                good_images[idx] += 1
                
    good_counts = dict()
    
    for im_idx, c in good_images.items():
        
        if c not in good_counts:
            good_counts[c] = [im_idx]
        else:
            good_counts[c].append(im_idx)
                
    return calib_runs_with_nonzero_good, good_counts


def select_indices(good_counts, low_threshold=0):
    
    selected= [] 
    
    counts =  filter(lambda c: c > low_threshold, good_counts.keys())
    
    for c in counts:
        selected += good_counts[c]
        
    return selected