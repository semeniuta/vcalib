import cv2
import os
import sys
import numpy as np
import pandas as pd
from glob import glob
import itertools

from visioncg.io import sorted_glob
from visioncg import cbcalib
from visioncg import geometry
from epypes.compgraph import CompGraphRunner

from .io import open_images_all


def prepare_points_for_all_images(runner_prepare, imfiles_1, imfiles_2):
    
    all_images_1 = open_images_all(imfiles_1)
    all_images_2 = open_images_all(imfiles_2)
    
    runner_prepare.run(
        calibration_images_1=all_images_1,
        calibration_images_2=all_images_2
    )


def create_runner_calib(im_wh):
    
    cg_calib = cbcalib.CGCalibrateStereoBase()
    params_calib = {'im_wh': im_wh}

    return CompGraphRunner(cg_calib, params_calib)
    
    
def run_calib(impoints_1, impoints_2, indices_subset, pattern_points, im_wh):

    runner_calib = create_runner_calib(im_wh)
    
    imp_1 = [impoints_1[idx] for idx in indices_subset]
    imp_2 = [impoints_2[idx] for idx in indices_subset]
    obp = cbcalib.make_list_of_identical_pattern_points(len(indices_subset), pattern_points)

    runner_calib.run(
        image_points_1=imp_1,
        image_points_2=imp_2,
        object_points=obp
    )

    return runner_calib
        
    
def all_images_reprojection_error_for_subsets(calib_runners, runner_prepare):
    """
    For each indices subset generated by indices_subset_gen,
    perform stereo calibration. Then, given the resulting intrinsics,
    solve PnP problem and compute reprojection error for all images.
    Return two NumPy arrays of equal length, where each element 
    corresponds to reprojection error given all images 
    and intrinsics from calibration based on a specific images subset.
    """
    
    rms_list_1 = []
    rms_list_2 = []
    
    # for all images
    impoints_1 = runner_prepare['image_points_1']
    impoints_2 = runner_prepare['image_points_2']
    pattern_points = runner_prepare['pattern_points']
    
    def multiple_pnp(impoints, cm, dc): # capturing object_points

        rvecs = []
        tvecs = []

        for imp in impoints:
            _, rvec, tvec = cv2.solvePnP(pattern_points, imp, cm, dc) 
            rvecs.append(rvec)
            tvecs.append(tvec)

        return rvecs, tvecs
    
    object_points = cbcalib.make_list_of_identical_pattern_points(len(impoints_1), pattern_points)

    for rcalib in calib_runners:
               
        cm1 = rcalib['cm_1']
        dc1 = rcalib['dc_1']
        cm2 = rcalib['cm_2']
        dc2 = rcalib['dc_2']
        
        rvecs1, tvecs1 = multiple_pnp(impoints_1, cm1, dc1)
        rvecs2, tvecs2 = multiple_pnp(impoints_2, cm2, dc2)
        
        rms1 = cbcalib.reproject_and_measure_error(impoints_1, object_points, rvecs1, tvecs1, cm1, dc1)
        rms2 = cbcalib.reproject_and_measure_error(impoints_2, object_points, rvecs2, tvecs2, cm2, dc2)

        rms_list_1.append(rms1)
        rms_list_2.append(rms2)
        
    return np.array(rms_list_1), np.array(rms_list_2)


def run_calib_for_subsets(subsets, runner_prepare, im_wh):
    
    impoints_1 = runner_prepare['image_points_1']
    impoints_2 = runner_prepare['image_points_2']
    pattern_points = runner_prepare['pattern_points']
    pattern_size = runner_prepare['pattern_size_wh']

    runners = []

    for indices in subsets:
        
        runner_calib = run_calib(impoints_1, impoints_2, indices, pattern_points, im_wh)
        runners.append(runner_calib)

    return runners
        

def all_images_triangulate_for_subsets(calib_runners, runner_prepare):
    
    res = []

    ip_1 = runner_prepare['image_points_1']
    ip_2 = runner_prepare['image_points_2']
    
    for rcalib in calib_runners:

        cm1 = rcalib['cm_1']
        dc1 = rcalib['dc_1']
        cm2 = rcalib['cm_2']
        dc2 = rcalib['dc_2']
                    
        points_3d_all_images = cbcalib.triangulate_impoints(
            rcalib['P1'],
            rcalib['P2'],
            ip_1,
            ip_2
        )
       
        psize = runner_prepare['pattern_size_wh']
        measure = lambda p3d: measure_cb_distances_in_rows(p3d, psize)                           
        
        distances_all = [measure(p3d).mean() for p3d in points_3d_all_images]
        
        res.append(distances_all)
 
    # rows -- calibration runs
    # cols -- images
    return np.array(res) 


def triangulate_all(calib_runners, runner_prepare):

    res = []

    ip_1 = runner_prepare['image_points_1']
    ip_2 = runner_prepare['image_points_2']

    for rcalib in calib_runners:

        cm1 = rcalib['cm_1']
        dc1 = rcalib['dc_1']
        cm2 = rcalib['cm_2']
        dc2 = rcalib['dc_2']
        P1 = rcalib['P1']
        P2 = rcalib['P2']
        R1 = rcalib['R1']
        R2 = rcalib['R2']

        ip_1_ud = [cbcalib.undistort_points(src, cm1, dc1, P1, R1) for src in ip_1]
        ip_2_ud = [cbcalib.undistort_points(src, cm2, dc2, P2, R2) for src in ip_2]

        # triangulated point clouds for all images
        point_clouds = cbcalib.triangulate_impoints(P1, P2, ip_1_ud, ip_2_ud)

        res.append(point_clouds)

    return np.array(res)


def pnp_for_each_image_pair(runner_prepare, cm1, dc1, cm2, dc2):

    op = runner_prepare['pattern_points']

    n_images = len(runner_prepare['image_points_1'])

    rvecs_1 = []
    tvecs_1 = []

    rvecs_2 = []
    tvecs_2 = []

    for i in range(n_images):

        imp_1 = runner_prepare['image_points_1'][i]
        imp_2 = runner_prepare['image_points_2'][i]

        _, r1, t1 = cv2.solvePnP(op, imp_1, cm1, dc1)
        _, r2, t2 = cv2.solvePnP(op, imp_2, cm2, dc2)

        rvecs_1.append(r1.reshape(-1))
        tvecs_1.append(t1.reshape(-1))

        rvecs_2.append(r2.reshape(-1))
        tvecs_2.append(t2.reshape(-1))

    return np.array(rvecs_1), np.array(tvecs_1), np.array(rvecs_2), np.array(tvecs_2)
